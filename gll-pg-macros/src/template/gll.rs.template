/// Internals structs generated by gll-pg.
mod gll_generated {
    use super::*;
    use gll_pg_core::*;
    use std::fmt::{Debug, Write};
    use std::iter::Iterator;
    use std::collections::BTreeMap;

    /// All labels in GLL
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    pub(super) enum Label {
        Ret,
        L0,
{labels}
    }

    /// Terminals, non-terminals and eps
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    pub(super) enum Symbol {
        // terminals
{symbol_terminals}
        // non-terminals
{symbol_non_terminals}
        Eps,
    }

    impl GrammarSymbol for Symbol {
        fn is_eps(&self) -> bool {
            *self == Symbol::Eps
        }
    }

    impl GrammarLabel for Label {
        type Symbol = Symbol;

        fn first(&self) -> bool {
            use Label::*;
            [{label_first}].contains(self)
        }

        fn end(&self) -> Option<Symbol> {
            use Label::*;
            use Symbol::*;
            match self {
{label_end}
                _ => None,
            }
        }
    }

    /// The memoization storage of each non-terminal
    #[derive(Default)]
    struct ParseStorage {
{arenas}
{maps}
    }

    /// The result of GLL Parser.
    ///
    /// It implements StreamingIterator and produces derivations one by one with memoization.
    pub(super) struct ParseResult<'a> {
        parser: &'a mut {parser_type},
        input: Vec<LogosToken<'a, {token}>>,
        state: GSSState<Label>,
        possible_derivations: BTreeMap<SPPFNodeIndex, usize>,
        storage: ParseStorage,
        root: SPPFNodeIndex,
        first: bool,
        current_derivation: usize,
    }

    impl<'a> StreamingIterator for ParseResult<'a>  {
        type Item = {res_type};

        fn advance(&mut self) {
            if self.first {
                self.first = false;
                self.current_derivation = 0;
            } else {
                self.current_derivation += 1;
            }
            if self.current_derivation < self.possible_derivations[&self.root] {
                self.derive{start_symbol}(self.root, self.current_derivation);
            }
        }

        fn get(&self) -> Option<&Self::Item> {
            if self.current_derivation < self.possible_derivations[&self.root] {
                Some(&self.storage.arena_{start_symbol}[self.storage.map_{start_symbol}[&self.root][self.current_derivation]])
            } else {
                None
            }
        }
    }

    impl<'a> ParseResult<'a> {
        pub(super) fn new(input: Vec<LogosToken<'a, {token}>>, parser: &'a mut {parser_type}, state: GSSState<Label>, root: SPPFNodeIndex) -> Self {
            let mut res = Self {
                input,
                parser,
                state,
                possible_derivations: BTreeMap::new(),
                storage: ParseStorage::default(),
                root,
                first: true,
                current_derivation: 0,
            };
            let mut temp = BTreeMap::new();
            res.calc_derivation(res.root, &mut temp);
            res.possible_derivations = temp;
            res
        }

        fn calc_derivation(&self, node: SPPFNodeIndex, possible_derivations: &mut BTreeMap<SPPFNodeIndex, usize>) -> usize {
            if let Some(count) = possible_derivations.get(&node) {
                return *count;
            }
            let symbol_node = &self.state.sppf_nodes[node];
            let children = symbol_node.children().unwrap();
            let ret = if children.len() > 0 {
                let mut res = 0;
                for child in children {
                    let current_child = &self.state.sppf_nodes[*child];
                    if let gll_pg_core::SPPFNode::Packed(l, k, c) = current_child {
                        let leaves = self.state.collect_symbols(*child);
                        let mut prod = 1;
                        for leaf in leaves {
                            prod *= self.calc_derivation(leaf, possible_derivations);
                        }
                        possible_derivations.insert(*child, prod);
                        res += prod;
                    }
                }
                res
            } else {
                1
            };
            possible_derivations.insert(node, ret);
            ret
        }

{derive}
    }

    impl<'a> ParseResult<'a> {
        /// Print current GSS graph in graphviz format
        pub fn print_gss_dot(&self) -> String {
            self.state.print_gss_dot()
        }

        /// Print current SPPF graph in graphviz format
        pub fn print_sppf_dot(&self) -> String {
            self.state.print_sppf_dot()
        }
    }

}

impl {parser_type} {
    /// Run generated GLL parser on lexer.
    /// Return all possible derivations as a streaming iterator.
    #[allow(unreachable_code)]
    pub fn parse<'a>(&'a mut self, lexer: &'a mut logos::Lexer<{token}, {source}>) -> Option<gll_generated::ParseResult<'a>> {
        use std::collections::{BTreeMap, BTreeSet};
        use gll_pg_core::*;
        use gll_generated::{Label, Symbol};
        use logos::Source;
        let mut input = vec![];
        loop {
            if lexer.token == {token}::_Eps {
                lexer.advance();
                continue;
            }
            input.push(LogosToken {
                kind: lexer.token.clone(),
                slice: lexer.slice(),
            });
            if lexer.token == {token}::End {
                break;
            }
            lexer.advance();
        }
        let m = input.len() - 1;
        let mut graph: Graph<GSSNode<gll_generated::Label>, SPPFNodeIndex, Directed> = Graph::new();
        let mut nodes = BTreeMap::new();
        let initial_node = (Label::L0, 0);
        let initial_node_index = graph.add_node(initial_node);
        nodes.insert(initial_node, initial_node_index);

        let mut state = GSSState {
            graph,
            nodes,
            sppf_nodes: vec![SPPFNode::Dummy],
            initial_node_index,
            visited: vec![BTreeSet::new(); input.len()],
            todo: Vec::new(),
            pop: BTreeSet::new(),
            current_node_index: initial_node_index,
            current_sppf_node: 0,
            current_position: 0,
        };

        let mut current_label = Label::L{start_symbol};
        loop {
            match current_label {
                Label::L0 => {
                    if let Some((l, u, i, w)) = state.todo.pop() {
                        current_label = l;
                        state.current_node_index = u;
                        state.current_position = i;
                        state.current_sppf_node = w;
                    } else {
                        if let Some((index, _)) = state.sppf_nodes.iter().enumerate().find(|(_idx, node)| {
                            if let SPPFNode::Symbol(Symbol::NT_{start_symbol}, 0, node_m, _) = node {
                                *node_m == m
                            } else {
                                false
                            }
                        }) {
                            let result = gll_generated::ParseResult::new(input, self, state, index);
                            return Some(result);
                        } else {
                            return None;
                        }
                    }
                }
                Label::Ret => {
                    state.pop(
                        state.current_node_index,
                        state.current_position,
                        state.current_sppf_node,
                    );
                    current_label = Label::L0;
                }
{states}
                _ => unimplemented!()
            }
        }
    }
}
