mod gll_generated {

    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Label {
        Ret,
        L0,
{labels}
    }

    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Symbol {
        // terminals
{symbol_terminals}
        // non-terminals
{symbol_non_terminals}
        Eps,
    }

    impl gll_pg_core::GrammarSymbol for Symbol {
        fn is_eps(&self) -> bool {
            *self == Symbol::Eps
        }
    }

    impl gll_pg_core::GrammarLabel for Label {
        type Symbol = Symbol;

        fn first(&self) -> bool {
            use Label::*;
            [{label_first}].contains(self)
        }

        fn end(&self) -> Option<Symbol> {
            use Label::*;
            use Symbol::*;
            match self {
{label_end}
                _ => None,
            }
        }
    }
}

pub struct {parser_type} { }

impl {parser_type} {
{parsers}

    #[allow(unreachable_code)]
    pub fn parse(lexer: &mut logos::Lexer<{token}, {source}>) -> Vec<{res_type}> {
        use gll_pg_core::*;
        use gll_generated::{Label, Symbol};
        use logos::Source;
        let mut input = vec![];
        loop {
            if lexer.token == {token}::_Eps {
                lexer.advance();
                continue;
            }
            input.push(LogosToken {
                kind: lexer.token.clone(),
                slice: lexer.slice(),
            });
            if lexer.token == {token}::End {
                break;
            }
            lexer.advance();
        }
        let m = input.len() - 1;
        let mut graph: Graph<GSSNode<gll_generated::Label>, SPPFNodeIndex, Directed> = Graph::new();
        let mut nodes = BTreeMap::new();
        let initial_node = (Label::L0, 0);
        let initial_node_index = graph.add_node(initial_node);
        nodes.insert(initial_node, initial_node_index);

        let mut state = GSSState {
            graph,
            nodes,
            sppf_nodes: vec![SPPFNode::Dummy],
            initial_node_index,
            visited: vec![BTreeSet::new(); input.len()],
            todo: Vec::new(),
            pop: BTreeSet::new(),
            current_node_index: initial_node_index,
            current_sppf_node: 0,
            current_position: 0,
        };

        let mut current_label = Label::L{start_symbol};
        loop {
            match current_label {
                Label::L0 => {
                    if let Some((l, u, i, w)) = state.todo.pop() {
                        current_label = l;
                        state.current_node_index = u;
                        state.current_position = i;
                        state.current_sppf_node = w;
                    } else {
                        if let Some((index, _)) = state.sppf_nodes.iter().enumerate().find(|(_idx, node)| {
                            if let SPPFNode::Symbol(Symbol::NT_{start_symbol}, 0, node_m, _) = node {
                                *node_m == m
                            } else {
                                false
                            }
                        }) {
                            return Self::parse{start_symbol}(&input, &state, index);
                        } else {
                            return vec![];
                        }
                    }
                }
                Label::Ret => {
                    state.pop(
                        state.current_node_index,
                        state.current_position,
                        state.current_sppf_node,
                    );
                    current_label = Label::L0;
                }
{states}
                _ => unimplemented!()
            }
        }
    }
}